Kotlin in Action

PART 1: INTRODUCTION 
1 Kotlin : What and Why                     OK
2 Kotlin basics 
3 Defining and Calling Functions 
4 Classes, Objects,and Interfaces  OK
5 Programming with lambdas          OK
6 The Kotlin Type System OK

PART 2: EMBRACING KOTLIN 
7 Operator Overloading and Other Conventions 
8 Higher-Order Functions : Lambdas as Parameters and Return Values 
9 Generics 
10 Annotations and Reflection 

 Classes, objects, and interfaces 
—————————————————
- interfaces can contain property declarations 
- Kotlin’s declarations are final and public by default 
- Nested classes aren’t inner by default : they don’t contain an implicit reference to their outer class. 
- Declaring a class as a data class instructs the compiler to generate several standard methods for this class 
- object keyword : 
    - Declares a class and also creates an instance of the class 
    - Used to express SINGLETON objects, companion objects, and object expressions (analogous to Java anonymous classes) 
- sealed modifier, which restricts the possible subclasses of a class. 

———————————————
4.1 Defining class hierarchies
———————————————

4.1.1 Interfaces in Kotlin have methods with default implementations
- Can’t contain any state 
- “:” in K <=> “extends” and “implements” in Java

4.1.2 Open, final, and abstract modifiers: final by default
- Whereas Java’s classes and methods are open by default, Kotlin’s are final by default 
- If you override a member of a base class or interface, the overriding member will also be open by default
- Visibility modifiers: public by default 
- internal modifier : "visible inside a module." 
- Visibility in Kotlin (rule) : be as visible as the class or method itself 
- In Kotlin, and a protected member is only visible in the class and its subclasses. 
- extension functions of a class don’t get access to its private or protected members. 

4.1.4 Inner And nested classes: nested by default
- Kotlin nested classes don’t have access to the outer class instance  (unless you specifically request that - use “inner” modifier) 
- A nested class in Kotlin with no explicit modifiers is the same as a static nested class in Java 
- Nested classes don’t reference their outer class, whereas inner classes do. 
- Sealed make a class unsubclassable 
- Sealed classes can’t have inheritors defined outside of the class. 

————————————————————————————————
 4.2 Declaring a class with nontrivial constructors or properties
————————————————————————————————

4.2.1 Initializing classes: primary constructor and initializer blocks 
- “constructor(..)” Primary constructor 
- “init” initializer block 
- default value for the constructor parameter 

4.2.3 Implementing properties declared in interfaces
- Interface can contain abstract property declarations
- Interface can contain abstract property declarations with custom getter. 
- Properties implemented in interface doesn’t have access to backing field
- Properties implemented in class do have full access to backing field

4.2.4 Accessing a backing field from a getter or setter
- There is two kind of properties
    - One’s that store values
    - One’s that has custom accessors  (that calcule values at every access)
- Every property have a backing field represented by “field” identifier that allow the access to it’s value
- In Setter it’s possible to read and write
- In Getter it’s possible to only read
4.2.5 Changing accessor visibility
- By default accessors have the same visibility as their field
- We can change accessors visibility in some cases
- latinit : the property (non-null) will be initialized later after the constructor initialization
- Lazy initialized properties
- @JvmField : expose a public field without accessors
—————————————————————————————————————
  4.3 Compiler-generated methods: data classes and class delegation
——————————————————————————————————
4.3.1 Universal object methods
- toString(), equals(), and hashCode() 
4.3.2 Data classes: autogenerated implementations of universal methods
- toString(), equals(), and hashCode() 
- copy
- Note : those method only include the fields in the primary constructor
4.3.3 Class delegation: using the "by" keyword
- class delegation solve the common problem in the design of O.O.P system caused by inheritance
    - Firstly, Kotlin solve this by making class by default non-inheritable
    - In java this problem is handled through the Decorator pattern -> code boilerplate
- Whenever you’re implementing an interface, you can say that you’re delegating the implementation of the interface to another object  using “by” keyword
———————————————————————————————————————
4.4 Declaring a class and creating an instance, combined, with the object keyword
———————————————————————————————————————
- object : define and create an instance
- Situation when to use object
    - Singleton
    - Companion object
    - Object expression is used instead of Java’s anonymous inner class

4.4.1 Object declarations: singletons made easy
- object declaration can inherit from class and interface

4.4.2 Companion objects: a place for factory methods and static members “companion”
- Java’s static keyword isn’t part of the Kotlin language .. instead Kotlin relies on :
    - Package-level functions (replace Java’s static method’s in many situations)
    - Object declarations (replace java static methods and static fields)
- Ideal candidate to implement the factory pattern 
- Ability to access the methods and properties of that object (communion object) directly through the name of the containing class 
- The companion object has access to all private members of the class 
 4.4.3 Companion objects as regular objects
- can be : 
    - Named
    - Implement an interface
    - Have extensions function
    - Have properties
Note : The thing that I don’t like in using them as regular objects is that they broke the Single Responsibility Principale

4.4.4 Object expressions: anonymous inner classes rephrased
- omit the name of the object
- Used as event listener

 Chapter 9 : Generics 
———————————
	 —————————
type parameters : placeholder for a specific type that a client specifies when they instantiate a variable of the generic type.
—————————
New concepts (comparing to java
- Reified  (make more concret =/= erasure) type parameters : refer type at runtime, work for inline function only
- Declaration site-variance : specify whether a generic type with a type argument is a subtype or supertype
    - it’s possible to pass arguments of type List<Int> to functions expecting List<Any> 
    - same as Java’s wildcards
——————————————
9.1 Generic type parameters
——————————————
- Generics : Allow define types with type parameters
- Generics : Type<typeParameter>  
- When an instance of Generics is created the Type Parameters is SUBSTITUTED with a specific type called Type Argument
- the Type Parameters lets specify exactly that Instead of “this variable holds a list” —> ‘’This variable holds a list of Strings’
- raw type : generic type without type arguments.

9.1.1 Generic functions and properties
- fun <T> List<T>.slice(indices : IntRange): List<T>  —> The function’s type parameter T is used in the receiver type and in the return type.
9.1.2 Declaring generic classes
- If your class extends a generic class (or implements a generic interface), you have to provide a type argument for the generic parameter of the base type. It can be either a specific type or another type parameter: 
- A class can even refer to itself as a type argument. 
9.1.3 Type parameter constraints
- Type parameter constraints let you restrict the types that can be used as type arguments for a class or function. 
- upper bound : example : the sum method can work with int and double —> fun<T : Number> List<T>.sum(): T
9.1.4 Making type parameters non-null
- <T : Any> 
—————————————————————————————
9.2 Generics at runtime: erased and reified type parameters
—————————————————————————————
- Generics on the JVM are implemented through type erasure : meaning the type arguments of an instance of a generic class aren’t preserved at runtime 
- There is a limitation in Kotlin about type erasure that it’s solved by inline functions
9.2.1 Generics at runtime: type checks and casts
- Kotlin/Java : Generics are erased at runtime —> an instance of a Generics class doesn’t carry information about type arguments used to create that instance.
- At RUNTIME List<String> —> List
- Example : 
// at runtime list1 and list2 are just List
var list1: List<String> = listOf(“a”,”b,””c”)
var list2: List<Int> = listOf(1,2,3)
// at compile time the compiler see List<String> and List<Int>
- Very IMPORTANT :  Type argument aren’t stored —> can’t be checked —> we can’t do : if(value is List<String>)
- erasing generic type information has its benefits: the overall amount of memory used by your application is smaller, because less type information needs to be saved in memory. 
- star projection syntax : check that the value is a list, not a set or another object. : if ( value is List<*> ) note: <*> <=> <?>
- “is” work only if the left identifier is know, 
Example :
fun printSum(c: Collection<Int>) 
{ if (c is List<Int>) { println(c.sum()) //This check is legitimate. 
} } 
9.2.2 Declaring functions with reified type parameters
- The same apply to function type parameter comparably to class type parameter (True in general, exception with inline functions)
Example :
fun <T> isA(value: Any) = value is T Error: Cannot check for instance of erased type: T 
    - Type parameters of inline functions can be reified —> we can refer to actual argument at runtime 
- when the compiler find a function declaration with inline keyword he replace every call to the function with the function declaration
Example :
inline fun <reified T> isA(value: Any) = value is T 
>>> println(isA<String>("abc")) true >>> println(isA<String>(123)) false 

9.2.3 Replacing class references with reified type parameters
- Service::class.java <—> Service.class
Example: (shorter)
val serviceImpl = ServiceLoader.load(Service::class.java) ——> val serviceImpl = loadService<Service>() 

9.2.4 Restrictions on reified type parameters
 How you can use a reified type parameter: 
- In type checks and casts (is, !is, as, as?)
- To use the Kotlin reflection APIs 
- To get the corresponding java.lang.Class (::class.java)
- As a type parameter to call other functions 
——————————————————
9.3 Variance: generics and subtyping
——————————————————
The concept of variance describes how types with same base type (List) and different type arguments <Any> relate to each other
EXAMPLE : List<String> and List<Any>

9.3.1 Why variance exists: passing an argument to a function 
- It’s all about code safety (type inconsistencies)  and clarity
EXAMPLE : 
fun addAnswer(list: MutableList<Any>) { 
    list.add(42) 
} 
val strings = mutableListOf("abc", "bac") 
addAnswer(strings) 
println(strings.maxBy { it.length }) // ClassCastException: Integer cannot be cast to String 
9.3.2 Classes, types, and subtyping
- type : the Type of variable specifies the possible value of this variable.
- in case of non-generic class the name of the class can be used directly as a type.
- in Kotlin every class name can be used to create at least to types
- List isn’t a type it’s a class
- generic class became a type when we substitute the type parameter; 
- Important : Each generic class produces a potentially infinite number of types; List<Int>, List<String?>, List<List<String>>, etc
- subtype : a type B is subtype of type A if the value of type B can be used instead of the type A value
	—> Int is a subtype of Number
	—> Int isn’t a subtype of String
-  subtype =/= supertype
- In case of Nullable subtype =/= subclass
- covariant —> List is a Read only collection
List<A> is a subtype of List<B> IF A is a subtype B
IMPORTANT : covariance, contravariance, invariant concerns the type parameter.
- invariant : for any two different type A and B, MutableList<A> isn’t a subtype or a supertype of MutableLiist<B>
9.3.3 Covariance: preserved subtyping relation 
A covariant class is a generic class (we’ll use Producer<T> as an example) iff Producer<A> is a subtype of Producer<B> if A is a subtype of B. —> subtyping is preserved.
IN KOTLIN : we put the “out” keyword before the name of the type parameter 
interface Producer<out T>{
    fun produce() :T
}
- Ignore the need to cast a class
- You can’t make any class covariant: it would be unsafe 
- out positions: the class can give out values of type T but not take them in. 
——————————————————————————————————————————————————————————————————
Let’s consider a class that declares a type parameter T and contains a function that uses T. 
We say that if T is used as the return type of a function, it’s in out position. In this case, the function produces (outputs) values of type T. 
If T is used as the type of a function parameter, it’s in in position. Such a function consumes values of type T 
———————————————————————————————————————————————————————————————————> To reiterate, the out keyword on the type parameter T means two things: 
* The subtyping is preserved (Producer<Cat> is a subtype of Producer<Animal>). 
* T can be used only in out positions 
- The variance rules protect a class from misuse by external clients and don’t come into play in the implementation of the class itself: 
9.3.4 Contravariance: reversed subtyping relation
The concept of contravariance is dual to covariance: for a contravariant class, the subtyping relation is the opposite of the subtyping relations of classes used as its type arguments.
- Comparator<Any> is a subtype of Comparator<String>, where Any is a supertype of String 
A contravariant class is a generic class (we’ll use Consumer<T> as an example) iff Consumer<A> is a subtype of Consumer<B> if A is a supertype of B. —> subtyping is reversed.
- “in” keyword : type are passed in
- Java doesn’t support variance of a class that is specified directly in its declaration and applies to all places where the class is used  and instead uses wildcards to specify the variance for specific uses of a class 
9.3.5 Use-site variance: specifying variance for type occurrences (here i am)
In Java, every time you use a type with a type parameter, you can also specify whether this type parameter can be replaced with its subtypes or supertypes. This is called use-site variance. 
9.3.6 Star projection: using * instead of a type parameter
‘*’ indicate that you have no information about a generic argument 
EXAMPLE : list of elements of an unknown type is expressed using that syntax as List<*>. 
IMPORTANT : <*> ==/== <Any?>
MutableList<*>       : holds elements of a specific type (that we don’t know what the type is)
MutableList<Any?> : holds elements of any type WHEN TO USE * : when the information about type arguments isn’t important 
                                    —> You don’t use any methods that refer to the type parameter in the signature
                                    —> You only read the data and you don’t care about its specific type 
